

--------------------------------------------------------------------
--  Tronca tabelle per schema

create procedure [dbo].[Test_Tronca_Tabelle_per_Schema]
as

declare @query_count varchar(max)
declare @query_truncate varchar(max)

declare @tmp_table_name varchar(max)


declare cur cursor for
SELECT TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME as tabella
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_schema='ax'

Open cur     
 
Fetch Next From cur Into @tmp_table_name
 
While (@@FETCH_STATUS = 0)
begin
	set @query_truncate = 'truncate table ' + @tmp_table_name
	exec @query_truncate
 
	Fetch Next From cur Into @tmp_table_name
 
end 


Close cur
Deallocate cur
 
GO


--------------------------------------------------------------------
-- SP STORICIZZAZIONE TABELLA

CREATE Procedure [dbo].[spStoricizzaCRM] 
as 
BEGIN

DECLARE @Today DATE
DECLARE @FirstDayMonth int
DECLARE @LastSnapshot nvarchar(50)

Set @Today = getdate()

Set @FirstDayMonth = case when month(@Today) <> month(dateadd(d,-1,@Today)) then 1
					  else 0
					  end

Set @LastSnapshot = (select max([VersioneSnapshot]) from [dbo].[HistoryCRM])
--print (@LastSnapshot)
--print ( cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) )

IF(@FirstDayMonth = 1 and @LastSnapshot <> cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))) --Se primo gg del mese e non esiste già lo snapshot --> lo creo
	BEGIN

		Insert Into [dbo].[HistoryCRM](
			[DataSnapshot]
			,[VersioneSnapshot]
			,[CustomerSid]
			,[Loyalty]
			,[Spending]
			,[SpendingEcommerce]
			,[SpendingStore]
		)
		Select
			@Today
			,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))
			,[Customer_SID]
			,[LOYALTY__C]
			,[SPENDING_FRM__C]
			,[SPENDING_E_COMMERCE_FRM__C]
			,[SPENDING_STORE_FRM__C]
		from [cfg].[CRMCustomerAttributes]
		--from [cfg].[MasterSlave]
		where [Customer_SID] <> ''

	END

ELSE		--> Se non è il primo del mese oppure esiste già lo snapshot, lo aggiorno.				
	BEGIN

		-- Allineo lo Snapshot del mese corrente
		MERGE [GZD_Stg].[dbo].[HistoryCRM] as Target --tabella nello stage
		USING
			(
			Select
				@Today							as [DataSnapshot]
				,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) as [VersioneSnapshot]
				,[Customer_SID]				as [CustomerSid]
				,[LOYALTY__C]					as [Loyalty]
				,[SPENDING_FRM__C]				as [Spending]
				,[SPENDING_E_COMMERCE_FRM__C]	as [SpendingEcommerce]
				,[SPENDING_STORE_FRM__C]		as [SpendingStore]
			--from [cfg].[MasterSlave]
			from [cfg].[CRMCustomerAttributes]
			where [Customer_SID] <> ''
			) as Source

			ON target.[VersioneSnapshot] = Source.[VersioneSnapshot]
			and target.[CustomerSid] = Source.[CustomerSid]
			
		WHEN MATCHED 
			AND target.[DataSnapshot]		<> source.[DataSnapshot]	
			or target.[Loyalty]				<> source.[Loyalty]
			or target.[Spending]			<> source.[Spending]
			or target.[SpendingEcommerce]	<> source.[SpendingEcommerce]
			or target.[SpendingStore]		<> source.[SpendingStore]
			THEN

		UPDATE SET
			target.[DataSnapshot]		= source.[DataSnapshot]	
			,target.[VersioneSnapshot]	= source.[VersioneSnapshot]
			,target.[CustomerSid]		= source.[CustomerSid]
			,target.[Loyalty]			= source.[Loyalty]
			,target.[Spending]			= source.[Spending]
			,target.[SpendingEcommerce]	= source.[SpendingEcommerce]
			,target.[SpendingStore]		= source.[SpendingStore]

		WHEN NOT MATCHED BY TARGET THEN
		INSERT (
				[DataSnapshot]
				,[VersioneSnapshot]
				,[CustomerSid]
				,[Loyalty]
				,[Spending]
				,[SpendingEcommerce]
				,[SpendingStore]
			)
		VALUES (
			source.[DataSnapshot]
			,source.[VersioneSnapshot]
			,source.[CustomerSid]
			,source.[Loyalty]
			,source.[Spending]
			,source.[SpendingEcommerce]
			,source.[SpendingStore]
		);
	END
END

------------------------------------------------------------------------------------------------------------
-- PARAMETRI PROCEDURA DATI TO SQL

CREATE Procedure [dbo].[Bdg_DataToExcel] @Bu as nvarchar(255)
,@Region as nvarchar(255)
,@Agent as nvarchar(255)
as
SET NOCOUNT ON
SET ANSI_WARNINGS OFF

EXEC msdb.dbo.sp_start_job N'Bdg_ToSQL_Currency'

------------------------------------------------------------------------------------------------------------
-- Compressione Tabelle

ALTER TABLE nav.PriceConfigurationES REBUILD PARTITION = ALL 

WITH (DATA_COMPRESSION = ROW); 

ALTER TABLE dbo.FactsInvCrMStage REBUILD PARTITION = ALL 

WITH (DATA_COMPRESSION = ROW);  

------------------------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------------------------
-- SSRS DateFrom / DateTo 

Nella query MDX aggiungere un nuovo calculated member in basso a sinistra 

SUM({STRTOMEMBER(@DateFrom): STRTOMEMBER(@DimDateDate)},[Measures].[Quantity Inventory]) 

------------------------------------------------------------------------------------------------------------
-- SSRS Defalut data con OLAP Data Source

="[Data].[Data].&[" + Format(CDate(DateAdd("d", -1, today())),"yyyy-MM-dd") + "T00:00:00]" 



------------------------------------------------------------------------------------------------------------
-- PIVOT SQL
First up, here are some quick table definitions and data for use:

CREATE TABLE #yt 
(
  [Store] int, 
  [Week] int, 
  [xCount] int
);
INSERT INTO #yt
(
  [Store], 
  [Week], [xCount]
)
VALUES
    (102, 1, 96),
    (101, 1, 138),
    (105, 1, 37),
    (109, 1, 59),
    (101, 2, 282),
    (102, 2, 212),
    (105, 2, 78),
    (109, 2, 97),
    (105, 3, 60),
    (102, 3, 123),
    (101, 3, 220),
    (109, 3, 87);

If your values are known, then you will hard-code the query:

select *
from 
(
  select store, week, xCount
  from yt
) src
pivot
(
  sum(xcount)
  for week in ([1], [2], [3])
) piv;

Then if you need to generate the week number dynamically, your code will be:

DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX)

select @cols = STUFF((SELECT ',' + QUOTENAME(Week) 
                    from yt
                    group by Week
                    order by Week
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT store,' + @cols + ' from 
             (
                select store, week, xCount
                from yt
            ) x
            pivot 
            (
                sum(xCount)
                for week in (' + @cols + ')
            ) p '

execute(@query);


------------------------------------------------------------------------------------------------------------
-- UNPIVOT

select u.name, u.subject, u.marks
from student s
unpivot
(
  marks
  for subject in (Maths, Science, English)
) u;
