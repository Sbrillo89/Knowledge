

-- Estrazione della data da Anno-Settimana

  cast(DATEADD(wk, DATEDIFF(wk, 7, CAST(tab.[Anno] AS NVARCHAR(100))) + (tab.[settimana]-1), 7) as date) as [Date]


-- Rimozione duplicati

DELETE 
FROM MyTable
LEFT OUTER JOIN (
                  SELECT MIN(RowId) as RowId, Col1, Col2, Col3 
                  FROM MyTable 
                  GROUP BY Col1, Col2, Col3
                ) as KeepRows 
                ON MyTable.RowId = KeepRows.RowId
WHERE
  KeepRows.RowId IS NULL


-- Check Status Shrink

SELECT 
   percent_complete
  ,start_time, status
  ,command
  ,estimated_completion_time
  ,cpu_time
  ,total_elapsed_time 
FROM sys.dm_exec_requests 


-- Check Table Lock

SELECT *  
FROM sys.dm_exec_requests 
WHERE 
  DB_NAME(database_id) = 'DB_NAME'  -- Sostituire con il nome del DB da controllare
  AND blocking_session_id <> 0 


-- 
--  Tronca tabelle per schema
--

create procedure [dbo].[Test_Tronca_Tabelle_per_Schema]
as

declare @query_count varchar(max)
declare @query_truncate varchar(max)

declare @tmp_table_name varchar(max)


declare cur cursor for
SELECT TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME as tabella
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_schema='ax'



Open cur     
 
Fetch Next From cur Into @tmp_table_name
 
While (@@FETCH_STATUS = 0)
begin
	set @query_truncate = 'truncate table ' + @tmp_table_name
	exec @query_truncate
 
	Fetch Next From cur Into @tmp_table_name
 
end 


Close cur
Deallocate cur
 
GO

--------------------------------------------------------------------
-- SPAZIO OCCUPATO TABELLE

SELECT
t.NAME AS TableName,
s.Name AS SchemaName,
p.rows AS RowCounts,
SUM(a.total_pages) * 8 / 1024 AS TotalSpaceMB,
SUM(a.used_pages) * 8 / 1024 AS UsedSpaceMB,
(SUM(a.total_pages) - SUM(a.used_pages)) * 8 / 1024 AS UnusedSpaceMB
FROM sys.tables t
INNER JOIN sys.indexes i
	ON t.OBJECT_ID = i.object_id
INNER JOIN sys.partitions p
	ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN sys.allocation_units a 
	ON p.partition_id = a.container_id
LEFT OUTER JOIN
	sys.schemas s 
	ON t.schema_id = s.schema_id
WHERE
	t.NAME NOT LIKE 'dt%'
	AND t.is_ms_shipped = 0
	AND i.OBJECT_ID > 255
GROUP BY
	t.Name, s.Name, p.Rows
ORDER BY
	SUM(a.total_pages) desc


--------------------------------------------------------------------
-- SP STORICIZZAZIONE TABELLA

CREATE Procedure [dbo].[spStoricizzaCRM] 
as 
BEGIN

DECLARE @Today DATE
DECLARE @FirstDayMonth int
DECLARE @LastSnapshot nvarchar(50)

Set @Today = getdate()

Set @FirstDayMonth = case when month(@Today) <> month(dateadd(d,-1,@Today)) then 1
					  else 0
					  end

Set @LastSnapshot = (select max([VersioneSnapshot]) from [dbo].[HistoryCRM])
--print (@LastSnapshot)
--print ( cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) )

IF(@FirstDayMonth = 1 and @LastSnapshot <> cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))) --Se primo gg del mese e non esiste già lo snapshot --> lo creo
	BEGIN

		Insert Into [dbo].[HistoryCRM](
			[DataSnapshot]
			,[VersioneSnapshot]
			,[CustomerSid]
			,[Loyalty]
			,[Spending]
			,[SpendingEcommerce]
			,[SpendingStore]
		)
		Select
			@Today
			,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))
			,[Customer_SID]
			,[LOYALTY__C]
			,[SPENDING_FRM__C]
			,[SPENDING_E_COMMERCE_FRM__C]
			,[SPENDING_STORE_FRM__C]
		from [cfg].[CRMCustomerAttributes]
		--from [cfg].[MasterSlave]
		where [Customer_SID] <> ''

	END

ELSE		--> Se non è il primo del mese oppure esiste già lo snapshot, lo aggiorno.				
	BEGIN

		-- Allineo lo Snapshot del mese corrente
		MERGE [GZD_Stg].[dbo].[HistoryCRM] as Target --tabella nello stage
		USING
			(
			Select
				@Today							as [DataSnapshot]
				,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) as [VersioneSnapshot]
				,[Customer_SID]				as [CustomerSid]
				,[LOYALTY__C]					as [Loyalty]
				,[SPENDING_FRM__C]				as [Spending]
				,[SPENDING_E_COMMERCE_FRM__C]	as [SpendingEcommerce]
				,[SPENDING_STORE_FRM__C]		as [SpendingStore]
			--from [cfg].[MasterSlave]
			from [cfg].[CRMCustomerAttributes]
			where [Customer_SID] <> ''
			) as Source

			ON target.[VersioneSnapshot] = Source.[VersioneSnapshot]
			and target.[CustomerSid] = Source.[CustomerSid]
			
		WHEN MATCHED 
			AND target.[DataSnapshot]		<> source.[DataSnapshot]	
			or target.[Loyalty]				<> source.[Loyalty]
			or target.[Spending]			<> source.[Spending]
			or target.[SpendingEcommerce]	<> source.[SpendingEcommerce]
			or target.[SpendingStore]		<> source.[SpendingStore]
			THEN

		UPDATE SET
			target.[DataSnapshot]		= source.[DataSnapshot]	
			,target.[VersioneSnapshot]	= source.[VersioneSnapshot]
			,target.[CustomerSid]		= source.[CustomerSid]
			,target.[Loyalty]			= source.[Loyalty]
			,target.[Spending]			= source.[Spending]
			,target.[SpendingEcommerce]	= source.[SpendingEcommerce]
			,target.[SpendingStore]		= source.[SpendingStore]

		WHEN NOT MATCHED BY TARGET THEN
		INSERT (
				[DataSnapshot]
				,[VersioneSnapshot]
				,[CustomerSid]
				,[Loyalty]
				,[Spending]
				,[SpendingEcommerce]
				,[SpendingStore]
			)
		VALUES (
			source.[DataSnapshot]
			,source.[VersioneSnapshot]
			,source.[CustomerSid]
			,source.[Loyalty]
			,source.[Spending]
			,source.[SpendingEcommerce]
			,source.[SpendingStore]
		);
	END
END

------------------------------------------------------------------------------------------------------------
-- PARAMETRI PROCEDURA DATI TO SQL

CREATE Procedure [dbo].[Bdg_DataToExcel] @Bu as nvarchar(255)
										,@Region as nvarchar(255)
										,@Agent as nvarchar(255)
as
SET NOCOUNT ON
SET ANSI_WARNINGS OFF


EXEC msdb.dbo.sp_start_job N'Bdg_ToSQL_Currency'

