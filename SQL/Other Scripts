

-- Estrazione della data da Anno-Settimana

  cast(DATEADD(wk, DATEDIFF(wk, 7, CAST(tab.[Anno] AS NVARCHAR(100))) + (tab.[settimana]-1), 7) as date) as [Date]


-- Rimozione duplicati

DELETE 
FROM MyTable
LEFT OUTER JOIN (
                  SELECT MIN(RowId) as RowId, Col1, Col2, Col3 
                  FROM MyTable 
                  GROUP BY Col1, Col2, Col3
                ) as KeepRows 
                ON MyTable.RowId = KeepRows.RowId
WHERE
  KeepRows.RowId IS NULL


-- Check Status Shrink

SELECT 
   percent_complete
  ,start_time, status
  ,command
  ,estimated_completion_time
  ,cpu_time
  ,total_elapsed_time 
FROM sys.dm_exec_requests 


-- Check Table Lock

SELECT *  
FROM sys.dm_exec_requests 
WHERE 
  DB_NAME(database_id) = 'DB_NAME'  -- Sostituire con il nome del DB da controllare
  AND blocking_session_id <> 0 


-- 
--  Tronca tabelle per schema
--

create procedure [dbo].[Test_Tronca_Tabelle_per_Schema]
as

declare @query_count varchar(max)
declare @query_truncate varchar(max)

declare @tmp_table_name varchar(max)


declare cur cursor for
SELECT TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME as tabella
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_schema='ax'



Open cur     
 
Fetch Next From cur Into @tmp_table_name
 
While (@@FETCH_STATUS = 0)
begin
	set @query_truncate = 'truncate table ' + @tmp_table_name
	exec @query_truncate
 
	Fetch Next From cur Into @tmp_table_name
 
end 


Close cur
Deallocate cur
 
GO

--------------------------------------------------------------------
-- SPAZIO OCCUPATO TABELLE

SELECT
t.NAME AS TableName,
s.Name AS SchemaName,
p.rows AS RowCounts,
SUM(a.total_pages) * 8 / 1024 AS TotalSpaceMB,
SUM(a.used_pages) * 8 / 1024 AS UsedSpaceMB,
(SUM(a.total_pages) - SUM(a.used_pages)) * 8 / 1024 AS UnusedSpaceMB
FROM sys.tables t
INNER JOIN sys.indexes i
	ON t.OBJECT_ID = i.object_id
INNER JOIN sys.partitions p
	ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN sys.allocation_units a 
	ON p.partition_id = a.container_id
LEFT OUTER JOIN
	sys.schemas s 
	ON t.schema_id = s.schema_id
WHERE
	t.NAME NOT LIKE 'dt%'
	AND t.is_ms_shipped = 0
	AND i.OBJECT_ID > 255
GROUP BY
	t.Name, s.Name, p.Rows
ORDER BY
	SUM(a.total_pages) desc


--------------------------------------------------------------------
-- SP STORICIZZAZIONE TABELLA

CREATE Procedure [dbo].[spStoricizzaCRM] 
as 
BEGIN

DECLARE @Today DATE
DECLARE @FirstDayMonth int
DECLARE @LastSnapshot nvarchar(50)

Set @Today = getdate()

Set @FirstDayMonth = case when month(@Today) <> month(dateadd(d,-1,@Today)) then 1
					  else 0
					  end

Set @LastSnapshot = (select max([VersioneSnapshot]) from [dbo].[HistoryCRM])
--print (@LastSnapshot)
--print ( cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) )

IF(@FirstDayMonth = 1 and @LastSnapshot <> cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))) --Se primo gg del mese e non esiste già lo snapshot --> lo creo
	BEGIN

		Insert Into [dbo].[HistoryCRM](
			[DataSnapshot]
			,[VersioneSnapshot]
			,[CustomerSid]
			,[Loyalty]
			,[Spending]
			,[SpendingEcommerce]
			,[SpendingStore]
		)
		Select
			@Today
			,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2))
			,[Customer_SID]
			,[LOYALTY__C]
			,[SPENDING_FRM__C]
			,[SPENDING_E_COMMERCE_FRM__C]
			,[SPENDING_STORE_FRM__C]
		from [cfg].[CRMCustomerAttributes]
		--from [cfg].[MasterSlave]
		where [Customer_SID] <> ''

	END

ELSE		--> Se non è il primo del mese oppure esiste già lo snapshot, lo aggiorno.				
	BEGIN

		-- Allineo lo Snapshot del mese corrente
		MERGE [GZD_Stg].[dbo].[HistoryCRM] as Target --tabella nello stage
		USING
			(
			Select
				@Today							as [DataSnapshot]
				,cast(year(@Today) as nvarchar(4)) + cast(month(@Today) as nvarchar(2)) as [VersioneSnapshot]
				,[Customer_SID]				as [CustomerSid]
				,[LOYALTY__C]					as [Loyalty]
				,[SPENDING_FRM__C]				as [Spending]
				,[SPENDING_E_COMMERCE_FRM__C]	as [SpendingEcommerce]
				,[SPENDING_STORE_FRM__C]		as [SpendingStore]
			--from [cfg].[MasterSlave]
			from [cfg].[CRMCustomerAttributes]
			where [Customer_SID] <> ''
			) as Source

			ON target.[VersioneSnapshot] = Source.[VersioneSnapshot]
			and target.[CustomerSid] = Source.[CustomerSid]
			
		WHEN MATCHED 
			AND target.[DataSnapshot]		<> source.[DataSnapshot]	
			or target.[Loyalty]				<> source.[Loyalty]
			or target.[Spending]			<> source.[Spending]
			or target.[SpendingEcommerce]	<> source.[SpendingEcommerce]
			or target.[SpendingStore]		<> source.[SpendingStore]
			THEN

		UPDATE SET
			target.[DataSnapshot]		= source.[DataSnapshot]	
			,target.[VersioneSnapshot]	= source.[VersioneSnapshot]
			,target.[CustomerSid]		= source.[CustomerSid]
			,target.[Loyalty]			= source.[Loyalty]
			,target.[Spending]			= source.[Spending]
			,target.[SpendingEcommerce]	= source.[SpendingEcommerce]
			,target.[SpendingStore]		= source.[SpendingStore]

		WHEN NOT MATCHED BY TARGET THEN
		INSERT (
				[DataSnapshot]
				,[VersioneSnapshot]
				,[CustomerSid]
				,[Loyalty]
				,[Spending]
				,[SpendingEcommerce]
				,[SpendingStore]
			)
		VALUES (
			source.[DataSnapshot]
			,source.[VersioneSnapshot]
			,source.[CustomerSid]
			,source.[Loyalty]
			,source.[Spending]
			,source.[SpendingEcommerce]
			,source.[SpendingStore]
		);
	END
END

------------------------------------------------------------------------------------------------------------
-- PARAMETRI PROCEDURA DATI TO SQL

CREATE Procedure [dbo].[Bdg_DataToExcel] @Bu as nvarchar(255)
										,@Region as nvarchar(255)
										,@Agent as nvarchar(255)
as
SET NOCOUNT ON
SET ANSI_WARNINGS OFF


EXEC msdb.dbo.sp_start_job N'Bdg_ToSQL_Currency'



------------------------------------------------------------------------------------------------------------
-- VISTE CREAZIONE DATE RANGE

create view [bi].[vExchangeRateDbwin_step1]
as
select
	[cod_divisa]
	,[cod_divisa_inc]
	,[data_cambio]
	,[coeff_cambio] as ExchangeRate
	,row_number() over (partition by [cod_divisa],[cod_divisa_inc] 
						order by [data_cambio] ) as RN
from [DbWin_dw].[vicini].[wl0_tbdivcambi]
where cod_divisa = 'EUR'
GO


CREATE view [bi].[vExchangeRateDbwin]
as
select --calcolo del range di validità DateFrom-DateTo 
		s1.cod_divisa
		,s1.cod_divisa_inc
		,s1.ExchangeRate
		,s1.data_cambio as DateFrom
		,DATEADD (day , -1 ,isnull(s2.data_cambio,dateadd(dd, +1, getdate()))) as DateTo
from [bi].[vExchangeRateDbwin_step1] s1
left outer join [bi].[vExchangeRateDbwin_step1] s2
	on s1.cod_divisa = s2.cod_divisa
	and s1.cod_divisa_inc = s2.cod_divisa_inc
	and s1.RN = s2.RN-1


------------------------------------------------------------------------------------------------------------
-- VISTE CREAZIONE RFM

CREATE VIEW [ml].[vCCBehaviour_M]
as
select 
	f.customerid   as CustomerID 
	   --mam 17/11/2016: azzero la monetary di clienti che ComproRendo e hanno monetary minuscola a causa dei tassi di cambio
	   ,case
			when sum(f.SalesNetValueTotalNoTAXLCY) = 0 then 0
			else sum(f.SalesNetValueTotalNoTAX)
		end as Monetary
from [dbo].[FactSales] f

left outer join [dbo].[DimCustomer] c
	on f.customerid = c.customerId
where
	--FILTRI USATI NEI REPORT 061
		f.[SalesRowTypeCode] = 'RS'
	--FILTRI USATI NEI REPORT 435
		AND f.SalesCausalGroup in ('Bargain','Normal','Event Sale')
		AND f.customerid <> 0
		AND c.customerTypeCode = '01'
group by f.customerid

CREATE VIEW [ml].[vCCBehaviour_R]
as
select 
		f.customerid   as CustomerID 
		,max(salesdate) as LastPurchaseDate
		,datediff(mm,max(salesdate),getdate())+1 as Recency
from [dbo].[FactSales] f

left outer join [dbo].[DimCustomer] c
	on f.customerid = c.customerId

where
	--FILTRI USATI NEI REPORT 061
		f.[SalesRowTypeCode] = 'RS'
	--FILTRI USATI NEI REPORT 435
		AND f.SalesCausalGroup in ('Bargain','Normal','Event Sale')
		AND f.customerid <> 0
		AND c.customerTypeCode = '01'
	--ESCLUSIONE DEI RESI--
	    AND f.SalesNetValueTotalNoTAX > 0 
group by f.customerid

CREATE VIEW [ml].[vCCBehaviour_F]
as
Select 

n.customerid
,n.Numeratore
,d.Denominatore
,cast((cast(n.Numeratore as float) / cast( d.Denominatore as Float)) as numeric(18,4)) as Frequency

from 
(
--NUMERATORE
select a.customerid
,count(*) as Numeratore

from(

select    
	f.customerid as CustomerID
	,f.storeid
	,f.salesdate

from [dbo].[FactSales] f
left outer join [dbo].[DimCustomer] c
	on f.customerid = c.customerId

where 
		--FILTRI USATI NEI REPORT 061
		 f.[SalesRowTypeCode] = 'RS'
		--FILTRI USATI NEI REPORT 435
		AND f.SalesCausalGroup in ('Bargain','Normal','Event Sale')
		AND f.customerid <> 0
		AND c.customerTypeCode = '01'
        AND f.SalesNetValueTotalNoTAX >0 --Escludiamo transazioni di solo reso
group by f.customerid
        ,f.storeid
	    ,f.salesdate
) a

group by a.customerid
)n

left outer join 
(
--DENOMINATORE
select 
		f.customerid   as CustomerID 
		,min(salesdate) as FirstPurchaseDate
		,datediff(mm,min(salesdate),getdate())+1 as Denominatore
from [dbo].[FactSales] f

left outer join [dbo].[DimCustomer] c
	on f.customerid = c.customerId

where
	--FILTRI USATI NEI REPORT 061
		f.[SalesRowTypeCode] = 'RS'
	--FILTRI USATI NEI REPORT 435
		AND f.SalesCausalGroup in ('Bargain','Normal','Event Sale')
		AND f.customerid <> 0
		AND c.customerTypeCode = '01'
	--ESCLUSIONE DEI RESI--
	    AND f.SalesNetValueTotalNoTAX > 0 
group by f.customerid
) d

on n.CustomerID = d.CustomerID

CREATE view [ml].[vCCBehaviour_RFM]
as
select

m.customerid

,r.Recency
,f.Frequency
,case 
		when m.Monetary < 10 then 0
		else m.Monetary 
	end as Monetary

--,f.Denominatore


from [ml].[vCCBehaviour_M] m

left outer join [ml].[vCCBehaviour_R] r
	on m.customerid = r.customerid

left outer join [ml].[vCCBehaviour_F] f
	on m.customerid = f.customerid

where r.recency is not NULL


------------------------------------------------------------------------------------------------------------
-- 
